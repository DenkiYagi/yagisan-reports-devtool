// Generated by Haxe 4.3.7
(function ($hx_exports, $global) { "use strict";
$hx_exports["yagisan"] = $hx_exports["yagisan"] || {};
$hx_exports["yagisan"]["reports"] = $hx_exports["yagisan"]["reports"] || {};
$hx_exports["yagisan"]["reports"]["devtool"] = $hx_exports["yagisan"]["reports"]["devtool"] || {};
$hx_exports["yagisan"]["reports"]["devtool"]["command"] = $hx_exports["yagisan"]["reports"]["devtool"]["command"] || {};
$hx_exports["yagisan"]["reports"]["devtool"]["command"]["GlyphdataCommand"] = $hx_exports["yagisan"]["reports"]["devtool"]["command"]["GlyphdataCommand"] || {};
;$hx_exports["yagisan"]["reports"]["devtool"]["command"]["YrtPackCommand"] = $hx_exports["yagisan"]["reports"]["devtool"]["command"]["YrtPackCommand"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
Math.__name__ = true;
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			return null;
		}
	}
	static deleteField(o,field) {
		if(!Object.prototype.hasOwnProperty.call(o,field)) {
			return false;
		}
		delete(o[field]);
		return true;
	}
}
Reflect.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
}
Std.__name__ = true;
class StringTools {
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static hex(n,digits) {
		let s = "";
		do {
			s = "0123456789ABCDEF".charAt(n & 15) + s;
			n >>>= 4;
		} while(n > 0);
		if(digits != null) {
			while(s.length < digits) s = "0" + s;
		}
		return s;
	}
}
StringTools.__name__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	toString() {
		return this.get_message();
	}
	get_message() {
		return this.message;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
haxe_Exception.__name__ = true;
class extype_Tuple2 {
	constructor(v1,v2) {
		this.value1 = v1;
		this.value2 = v2;
	}
}
extype_Tuple2.__name__ = true;
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
}
haxe_ValueException.__name__ = true;
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var js_npm_Fontkit = require("@denkiyagi/fontkit");
var js_npm_DefaultShaper = require("@denkiyagi/fontkit").DefaultShaper;
var js_npm_MsgPack = require("@msgpack/msgpack");
var js_npm_ExtensionCodec = require("@msgpack/msgpack").ExtensionCodec;
var js_npm_yargs_YArgs = require("yargs");
var js_npm_yargs_YArgsHelpers = require("yargs/helpers");
class js_npm_yargs_YArgs_$Extern0 {
	static _new(x) {
		if(x != null) {
			x["boolean-negation"] = Reflect.field(x,"booleanNegation");
			Reflect.deleteField(x,"booleanNegation");
		}
		if(x != null) {
			x["camel-case-expansion"] = Reflect.field(x,"camelCaseExpansion");
			Reflect.deleteField(x,"camelCaseExpansion");
		}
		if(x != null) {
			x["combine-arrays"] = Reflect.field(x,"combineArrays");
			Reflect.deleteField(x,"combineArrays");
		}
		if(x != null) {
			x["dot-notation"] = Reflect.field(x,"dotNotation");
			Reflect.deleteField(x,"dotNotation");
		}
		if(x != null) {
			x["duplicate-arguments-array"] = Reflect.field(x,"duplicateArgumentsArray");
			Reflect.deleteField(x,"duplicateArgumentsArray");
		}
		if(x != null) {
			x["flatten-duplicate-arrays"] = Reflect.field(x,"flattenDuplicateArrays");
			Reflect.deleteField(x,"flattenDuplicateArrays");
		}
		if(x != null) {
			x["greedy-arrays"] = Reflect.field(x,"greedyArrays");
			Reflect.deleteField(x,"greedyArrays");
		}
		if(x != null) {
			x["halt-at-non-option"] = Reflect.field(x,"haltAtNonOption");
			Reflect.deleteField(x,"haltAtNonOption");
		}
		if(x != null) {
			x["nargs-eats-options"] = Reflect.field(x,"nargsEatsOptions");
			Reflect.deleteField(x,"nargsEatsOptions");
		}
		if(x != null) {
			x["negation-prefix"] = Reflect.field(x,"negationPrefix");
			Reflect.deleteField(x,"negationPrefix");
		}
		if(x != null) {
			x["parse-numbers"] = Reflect.field(x,"parseNumbers");
			Reflect.deleteField(x,"parseNumbers");
		}
		if(x != null) {
			x["parse-positional-numbers"] = Reflect.field(x,"parsePositionalNumbers");
			Reflect.deleteField(x,"parsePositionalNumbers");
		}
		if(x != null) {
			x["populate--"] = Reflect.field(x,"populateMinusMinus");
			Reflect.deleteField(x,"populateMinusMinus");
		}
		if(x != null) {
			x["set-placeholder-key"] = Reflect.field(x,"setPlaceholderKey");
			Reflect.deleteField(x,"setPlaceholderKey");
		}
		if(x != null) {
			x["short-option-groups"] = Reflect.field(x,"shortOptionGroups");
			Reflect.deleteField(x,"shortOptionGroups");
		}
		if(x != null) {
			x["sort-commands"] = Reflect.field(x,"sortCommands");
			Reflect.deleteField(x,"sortCommands");
		}
		if(x != null) {
			x["strip-aliased"] = Reflect.field(x,"stripAliased");
			Reflect.deleteField(x,"stripAliased");
		}
		if(x != null) {
			x["strip-dashed"] = Reflect.field(x,"stripDashed");
			Reflect.deleteField(x,"stripDashed");
		}
		if(x != null) {
			x["unknown-options-as-args"] = Reflect.field(x,"unknownOptionsAsArgs");
			Reflect.deleteField(x,"unknownOptionsAsArgs");
		}
		return x;
	}
	static from(x) {
		return js_npm_yargs_YArgs_$Extern0._new(x);
	}
}
class yagisan_lib_ds_UInt16Pair {
	static of(x,y) {
		return x << 16 | y;
	}
	static get_x(this1) {
		return this1 >>> 16;
	}
	static get_y(this1) {
		return this1 & 65535;
	}
}
class yagisan_reports_core_font_FontLayoutTypeMapTools {
	static bake(factory) {
		return { horizontal : factory(), horizontalWithoutLigature : factory(), vertical : factory()};
	}
	static map(map,fn) {
		return { horizontal : fn(map.horizontal), horizontalWithoutLigature : fn(map.horizontalWithoutLigature), vertical : fn(map.vertical)};
	}
	static getDuplicate(map,fn,equalsFn) {
		let result1 = fn(map.horizontal);
		let result2 = fn(map.horizontalWithoutLigature);
		if(equalsFn(result1,result2)) {
			if(equalsFn(result2,fn(map.vertical))) {
				return result1;
			} else {
				return undefined;
			}
		} else {
			return undefined;
		}
	}
	static iter(map,fn) {
		fn(map.horizontal);
		fn(map.horizontalWithoutLigature);
		fn(map.vertical);
	}
	static zipToVoid(map,other,fn) {
		fn(map.horizontal,other.horizontal);
		fn(map.horizontalWithoutLigature,other.horizontalWithoutLigature);
		fn(map.vertical,other.vertical);
	}
}
yagisan_reports_core_font_FontLayoutTypeMapTools.__name__ = true;
class yagisan_reports_core_font_glyphdata_GlyphDataFatalError extends Error {
	constructor(type) {
		super(yagisan_reports_core_font_glyphdata_GlyphDataFatalErrorTypeTools.getHaxeException(type).get_message());
		this.name = yagisan_reports_core_font_glyphdata_GlyphDataFatalErrorTypeTools.getErrorName(type);
		this.type = type;
	}
}
yagisan_reports_core_font_glyphdata_GlyphDataFatalError.__name__ = true;
var yagisan_reports_core_font_glyphdata_GlyphDataFatalErrorType = $hxEnums["yagisan.reports.core.font.glyphdata.GlyphDataFatalErrorType"] = { __ename__:true,__constructs__:null
	,AssertionError: ($_=function(exception) { return {_hx_index:0,exception:exception,__enum__:"yagisan.reports.core.font.glyphdata.GlyphDataFatalErrorType",toString:$estr}; },$_._hx_name="AssertionError",$_.__params__ = ["exception"],$_)
	,UnknownError: ($_=function(exception) { return {_hx_index:1,exception:exception,__enum__:"yagisan.reports.core.font.glyphdata.GlyphDataFatalErrorType",toString:$estr}; },$_._hx_name="UnknownError",$_.__params__ = ["exception"],$_)
};
yagisan_reports_core_font_glyphdata_GlyphDataFatalErrorType.__constructs__ = [yagisan_reports_core_font_glyphdata_GlyphDataFatalErrorType.AssertionError,yagisan_reports_core_font_glyphdata_GlyphDataFatalErrorType.UnknownError];
class yagisan_reports_core_font_glyphdata_GlyphDataFatalErrorTypeTools {
	static getErrorName(type) {
		switch(type._hx_index) {
		case 0:
			return "YagisanReportsCoreGlyphDataAssertionError";
		case 1:
			return "YagisanReportsCoreGlyphDataUnknownError";
		}
	}
	static getHaxeException(type) {
		switch(type._hx_index) {
		case 0:
			return type.exception;
		case 1:
			return type.exception;
		}
	}
}
yagisan_reports_core_font_glyphdata_GlyphDataFatalErrorTypeTools.__name__ = true;
var yagisan_reports_core_font_glyphdata_GlyphDataGeneratorResult = $hxEnums["yagisan.reports.core.font.glyphdata.GlyphDataGeneratorResult"] = { __ename__:true,__constructs__:null
	,Success: ($_=function(glyphData,rawFont) { return {_hx_index:0,glyphData:glyphData,rawFont:rawFont,__enum__:"yagisan.reports.core.font.glyphdata.GlyphDataGeneratorResult",toString:$estr}; },$_._hx_name="Success",$_.__params__ = ["glyphData","rawFont"],$_)
	,UnsupportedFontFileError: ($_=function(type) { return {_hx_index:1,type:type,__enum__:"yagisan.reports.core.font.glyphdata.GlyphDataGeneratorResult",toString:$estr}; },$_._hx_name="UnsupportedFontFileError",$_.__params__ = ["type"],$_)
	,FatalError: ($_=function(error) { return {_hx_index:2,error:error,__enum__:"yagisan.reports.core.font.glyphdata.GlyphDataGeneratorResult",toString:$estr}; },$_._hx_name="FatalError",$_.__params__ = ["error"],$_)
};
yagisan_reports_core_font_glyphdata_GlyphDataGeneratorResult.__constructs__ = [yagisan_reports_core_font_glyphdata_GlyphDataGeneratorResult.Success,yagisan_reports_core_font_glyphdata_GlyphDataGeneratorResult.UnsupportedFontFileError,yagisan_reports_core_font_glyphdata_GlyphDataGeneratorResult.FatalError];
function yagisan_reports_core_font_glyphdata_GlyphDataGenerator_generateRawGlyphData(fontFile,glyphMappingOptions,$console) {
	try {
		let generatedGlyphMapping = yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_generateRawGlyphMapping(fontFile,glyphMappingOptions,$console != null ? $console : yagisan_reports_core_font_glyphdata_GlyphDataGenerator_createDefaultConsole());
		return yagisan_reports_core_font_glyphdata_GlyphDataGeneratorResult.Success({ version : yagisan_reports_core_font_glyphdata_GlyphDataVersion_currentGlyphDataVersion, glyphMapping : generatedGlyphMapping.data},generatedGlyphMapping.rawFont);
	} catch( _g ) {
		let _g1 = haxe_Exception.caught(_g);
		if(((_g1) instanceof yagisan_reports_core_font_glyphdata_GlyphDataMappingGeneratorUnsupportedFontFileException)) {
			return yagisan_reports_core_font_glyphdata_GlyphDataGeneratorResult.UnsupportedFontFileError(_g1.fontType);
		} else if(((_g1) instanceof yagisan_reports_core_font_glyphdata_GlyphDataMappingGeneratorGsubExtractorException)) {
			return yagisan_reports_core_font_glyphdata_GlyphDataGeneratorResult.FatalError(new yagisan_reports_core_font_glyphdata_GlyphDataFatalError(yagisan_reports_core_font_glyphdata_GlyphDataFatalErrorType.AssertionError(_g1)));
		} else if(((_g1) instanceof yagisan_reports_core_font_glyphdata_GlyphDataGeneralException)) {
			return yagisan_reports_core_font_glyphdata_GlyphDataGeneratorResult.FatalError(new yagisan_reports_core_font_glyphdata_GlyphDataFatalError(yagisan_reports_core_font_glyphdata_GlyphDataFatalErrorType.AssertionError(_g1)));
		} else {
			return yagisan_reports_core_font_glyphdata_GlyphDataGeneratorResult.FatalError(new yagisan_reports_core_font_glyphdata_GlyphDataFatalError(yagisan_reports_core_font_glyphdata_GlyphDataFatalErrorType.UnknownError(_g1)));
		}
	}
}
function yagisan_reports_core_font_glyphdata_GlyphDataGenerator_createDefaultConsole() {
	return new yagisan_reports_core_font_glyphdata_ConsoleLike(function(_) {
	},function() {
	},null,null,null,null,null);
}
class yagisan_reports_core_font_glyphdata_CodePoint {
	static arrayFrom(s) {
		if(s.length == 0) {
			return yagisan_reports_core_font_glyphdata_CodePoint.emptyArray;
		}
		let codePoints = [];
		for (const char of s) codePoints.push(char.codePointAt(0));
		return codePoints;
	}
	static of(v) {
		return v;
	}
	static ofIndex(s,index) {
		let nc = s.codePointAt(index);
		if(nc != null) {
			return nc;
		} else {
			return undefined;
		}
	}
	static toHex(this1) {
		return StringTools.hex(this1,4);
	}
}
class yagisan_reports_core_font_glyphdata_WithRawFont {
	constructor(data,rawFont) {
		this.data = data;
		this.rawFont = rawFont;
	}
}
yagisan_reports_core_font_glyphdata_WithRawFont.__name__ = true;
class yagisan_reports_core_font_glyphdata_GlyphDataGeneralException extends haxe_Exception {
	constructor(msg) {
		super(msg);
	}
	static glyphDataGeneralException(msg) {
		return new yagisan_reports_core_font_glyphdata_GlyphDataGeneralException(msg);
	}
}
yagisan_reports_core_font_glyphdata_GlyphDataGeneralException.__name__ = true;
class yagisan_reports_core_font_glyphdata_ConsoleLike {
	constructor(group,groupEnd,debug,log,info,warn,error) {
		this.error = function(_) {
		};
		this.warn = function(_) {
		};
		this.info = function(_) {
		};
		this.log = function(_) {
		};
		this.debug = function(_) {
		};
		this.group = group;
		this.groupEnd = groupEnd;
		if(debug != null) {
			this.debug = debug;
		}
		if(log != null) {
			this.log = log;
		}
		if(info != null) {
			this.info = info;
		}
		if(warn != null) {
			this.warn = warn;
		}
		if(error != null) {
			this.error = error;
		}
	}
}
yagisan_reports_core_font_glyphdata_ConsoleLike.__name__ = true;
class yagisan_reports_core_font_glyphdata_CountMap {
	static addCountFor(this1,key,countToAdd) {
		let x = this1.get(key);
		let nextCount = x != null ? x + countToAdd : countToAdd;
		this1.set(key,nextCount);
		return nextCount;
	}
	static incrementFor(this1,key) {
		return yagisan_reports_core_font_glyphdata_CountMap.addCountFor(this1,key,1);
	}
	static getKeyWithHighestCount(this1) {
		let keyWithHighestCount = null;
		let highestCount = 0;
		let jsIterator = this1.entries();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			let curCount = v[1];
			if(curCount > highestCount) {
				keyWithHighestCount = v[0];
				highestCount = curCount;
			}
		}
		return keyWithHighestCount;
	}
}
class yagisan_reports_core_font_glyphdata_GlyphDataUtils {
	static equalLoose(nA,nB) {
		return nA == nB;
	}
	static equalNullables(nA,nB,compare) {
		if(nA != null) {
			if(nB != null) {
				return compare(nA,nB);
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
}
yagisan_reports_core_font_glyphdata_GlyphDataUtils.__name__ = true;
class yagisan_reports_core_font_glyphdata_GlyphDataVersion {
	static from(version) {
		return version;
	}
}
class yagisan_reports_core_font_glyphdata_GlyphDataMappingGeneratorUnsupportedFontFileException extends haxe_Exception {
	constructor(type) {
		super("Unsupported font file type: " + type);
		this.fontType = type;
	}
}
yagisan_reports_core_font_glyphdata_GlyphDataMappingGeneratorUnsupportedFontFileException.__name__ = true;
class yagisan_reports_core_font_glyphdata_GlyphDataMappingGeneratorGsubExtractorException extends haxe_Exception {
	constructor(msg,native) {
		super(msg,null,native);
	}
}
yagisan_reports_core_font_glyphdata_GlyphDataMappingGeneratorGsubExtractorException.__name__ = true;
class yagisan_reports_core_font_glyphdata_GlyphMappingGeneratorOptions {
	constructor(codePointSet,codePointFilter,substitutionFilter,forceRemovingMostFrequentValue,lineBreakFn) {
		this.lineBreakFn = undefined;
		this.forceRemovingMostFrequentValue = false;
		this.substitutionFilter = undefined;
		this.codePointFilter = undefined;
		this.codePointSet = undefined;
		if(codePointSet != null) {
			this.codePointSet = codePointSet;
		}
		if(codePointFilter != null) {
			this.codePointFilter = codePointFilter;
		}
		if(substitutionFilter != null) {
			this.substitutionFilter = substitutionFilter;
		}
		if(forceRemovingMostFrequentValue != null) {
			this.forceRemovingMostFrequentValue = forceRemovingMostFrequentValue;
		}
		if(lineBreakFn != null) {
			this.lineBreakFn = lineBreakFn;
		}
	}
}
yagisan_reports_core_font_glyphdata_GlyphMappingGeneratorOptions.__name__ = true;
class yagisan_reports_core_font_glyphdata_shapers_BasicPresetShaper extends js_npm_DefaultShaper {
	constructor() {
		super();
	}
}
yagisan_reports_core_font_glyphdata_shapers_BasicPresetShaper.__name__ = true;
class yagisan_reports_core_font_glyphdata_shapers_HorizontalPresetShaper extends yagisan_reports_core_font_glyphdata_shapers_BasicPresetShaper {
	constructor() {
		super();
	}
}
yagisan_reports_core_font_glyphdata_shapers_HorizontalPresetShaper.__name__ = true;
class yagisan_reports_core_font_glyphdata_shapers_VerticalPresetShaper extends yagisan_reports_core_font_glyphdata_shapers_BasicPresetShaper {
	constructor() {
		super();
	}
}
yagisan_reports_core_font_glyphdata_shapers_VerticalPresetShaper.__name__ = true;
function yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_generateRawGlyphMapping(fontFile,options,$console) {
	let maybeFont = js_npm_Fontkit.create(fontFile);
	if(maybeFont.type != "TTF") {
		throw new yagisan_reports_core_font_glyphdata_GlyphDataMappingGeneratorUnsupportedFontFileException(maybeFont.type);
	}
	let font = maybeFont;
	$console.group("\nGenerating glyph mapping for: " + font.fullName);
	let glyphMapping = yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_generateGlyphMappingWithFontkit(font,yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_layoutAdvancedParams,options,$console);
	$console.groupEnd();
	return new yagisan_reports_core_font_glyphdata_WithRawFont(glyphMapping,font);
}
function yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_generateGlyphMappingWithFontkit(font,layoutAdvancedParams,options,$console) {
	let includeDefaultSize = options.codePointSet == null && options.codePointFilter == null;
	let codePointsRemovedByCodePointFilter = new Set();
	let stringsRemovedBySubstitutionFilter = new Set();
	let codePointsGlyphNotFound = new Set();
	let nonBasic = yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_extractNonBasicStrings(font,$console);
	let this1 = options.codePointFilter;
	let codePointFilter = this1 != null ? this1 : yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_anyToTrue;
	let this2 = options.substitutionFilter;
	let substitutionFilter = this2 != null ? this2 : yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_anyToTrue;
	let this3 = options.codePointSet;
	let entireCodePointList;
	if(this3 != null) {
		let codePoints = new Set();
		let jsIterator = this3.values();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			if(codePointFilter(v)) {
				codePoints.add(v);
			} else {
				codePointsRemovedByCodePointFilter.add(yagisan_reports_core_font_glyphdata_CodePoint.of(v));
			}
		}
		let jsIterator1 = nonBasic.singleCodePoints.values();
		let _g_lastStep1 = jsIterator1.next();
		while(!_g_lastStep1.done) {
			let v = _g_lastStep1.value;
			_g_lastStep1 = jsIterator1.next();
			if(codePointFilter(v)) {
				let char = String.fromCodePoint(v);
				if(substitutionFilter(char)) {
					codePoints.add(v);
				} else {
					stringsRemovedBySubstitutionFilter.add(char);
				}
			} else {
				codePointsRemovedByCodePointFilter.add(yagisan_reports_core_font_glyphdata_CodePoint.of(v));
			}
		}
		let _g = 0;
		let _g1 = nonBasic.charSequenceList;
		while(_g < _g1.length) {
			let charSequence = _g1[_g];
			++_g;
			let this1 = charSequence.codePointAt(0);
			if(this1 != null) {
				if(!codePoints.has(this1)) {
					if(codePointFilter(this1)) {
						String.fromCodePoint(this1);
						if(substitutionFilter(charSequence)) {
							codePoints.add(this1);
						} else {
							stringsRemovedBySubstitutionFilter.add(charSequence);
						}
					} else {
						codePointsRemovedByCodePointFilter.add(yagisan_reports_core_font_glyphdata_CodePoint.of(this1));
					}
				}
			}
		}
		let _g2 = [];
		let jsIterator2 = codePoints.values();
		let _g_lastStep2 = jsIterator2.next();
		while(!_g_lastStep2.done) {
			let v = _g_lastStep2.value;
			_g_lastStep2 = jsIterator2.next();
			_g2.push(v);
		}
		_g2.sort(function(a,b) {
			return a - b;
		});
		entireCodePointList = _g2;
	} else {
		entireCodePointList = font.characterSet;
	}
	let map = new Map();
	let _g = 0;
	let _g1 = nonBasic.charSequenceList;
	while(_g < _g1.length) {
		let charSequence = _g1[_g];
		++_g;
		if(!substitutionFilter(charSequence)) {
			stringsRemovedBySubstitutionFilter.add(charSequence);
			continue;
		}
		let this1 = options.lineBreakFn;
		if(this1 != null) {
			let lineBreakUnits = this1(charSequence);
			if(lineBreakUnits.length > 1) {
				$console.warn("グリフ置換元の文字列が分離禁則単位を跨いでいます: " + charSequence + " -> " + Std.string(lineBreakUnits));
				$console.warn("折り返し処理では分離禁則単位ごとにグリフ情報の取得を行うため、この文字列パターンを検知できず、内部的な計算結果と最終的にPDFに書き込まれるグリフとで齟齬が発生する可能性があります。");
			}
		}
		let this2 = yagisan_reports_core_font_glyphdata_CodePoint.ofIndex(charSequence,0);
		if(this2 == null) {
			continue;
		}
		let x = map.get(this2);
		if(x != null) {
			x.push(charSequence);
		} else {
			map.set(this2,[charSequence]);
		}
	}
	let glyphIdAdvanceMap = new Map();
	let cacheGlyphAdvance = function(rawGlyph) {
		let x = glyphIdAdvanceMap.get(rawGlyph.id);
		if(x != null) {
			return x;
		} else {
			let advance = yagisan_reports_core_font_glyphdata_GlyphAdvanceRawData.fromRawGlyph(rawGlyph);
			glyphIdAdvanceMap.set(rawGlyph.id,advance);
			return advance;
		}
	};
	let basicGlyphAdvanceRawData = { width : yagisan_reports_core_font_glyphdata_ReversibleMap._new(), height : yagisan_reports_core_font_glyphdata_ReversibleMap._new(), common : yagisan_reports_core_font_glyphdata_ReversibleMap._new(), defaultValue : undefined};
	let singleCodePointSubstitutions = yagisan_reports_core_font_FontLayoutTypeMapTools.bake(function() {
		return yagisan_reports_core_font_glyphdata_ReversibleMap._new();
	});
	let multiCodePointSubstitution = yagisan_reports_core_font_FontLayoutTypeMapTools.bake(function() {
		return { charSequenceToGlyphAdvances : yagisan_reports_core_font_glyphdata_ReversibleMap._new()};
	});
	let _g2 = 0;
	while(_g2 < entireCodePointList.length) {
		let codePointValue = entireCodePointList[_g2];
		++_g2;
		let singleCodePointRawGlyph = font.glyphForCodePoint(codePointValue);
		if(singleCodePointRawGlyph == null) {
			codePointsGlyphNotFound.add(yagisan_reports_core_font_glyphdata_CodePoint.of(codePointValue));
			continue;
		}
		let codePoint = yagisan_reports_core_font_glyphdata_CodePoint.of(codePointValue);
		let curBasicGlyphAdvance = cacheGlyphAdvance(singleCodePointRawGlyph);
		if(yagisan_lib_ds_UInt16Pair.get_x(curBasicGlyphAdvance) == yagisan_lib_ds_UInt16Pair.get_y(curBasicGlyphAdvance)) {
			basicGlyphAdvanceRawData.common.set(codePoint,yagisan_lib_ds_UInt16Pair.get_x(curBasicGlyphAdvance));
		} else {
			basicGlyphAdvanceRawData.width.set(codePoint,yagisan_lib_ds_UInt16Pair.get_x(curBasicGlyphAdvance));
			basicGlyphAdvanceRawData.height.set(codePoint,yagisan_lib_ds_UInt16Pair.get_y(curBasicGlyphAdvance));
		}
		let char = String.fromCodePoint(codePoint);
		yagisan_reports_core_font_FontLayoutTypeMapTools.zipToVoid(yagisan_reports_core_font_FontLayoutTypeMapTools.map(layoutAdvancedParams,function(params) {
			return font.layout(char,undefined,params).glyphs;
		}),singleCodePointSubstitutions,function(fontkitGlyphs,singleCodePointSubstitution) {
			if(!(fontkitGlyphs.length == 1 && fontkitGlyphs[0].id == singleCodePointRawGlyph.id)) {
				let f = cacheGlyphAdvance;
				let result = new Array(fontkitGlyphs.length);
				let _g = 0;
				let _g1 = fontkitGlyphs.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = f(fontkitGlyphs[i]);
				}
				if(!(result.length == 1 && yagisan_reports_core_font_glyphdata_GlyphAdvanceRawData.equals(result[0],curBasicGlyphAdvance))) {
					if(substitutionFilter(char)) {
						singleCodePointSubstitution.set(codePoint,yagisan_reports_core_font_glyphdata_GlyphAdvancesString.glyphAdvancesToString(result));
					} else {
						stringsRemovedBySubstitutionFilter.add(char);
					}
				}
			}
		});
		let x = map.get(codePoint);
		if(x != null) {
			let _g = 0;
			while(_g < x.length) {
				let charSequence = x[_g++];
				let compositeGlyphs = yagisan_reports_core_font_FontLayoutTypeMapTools.map(layoutAdvancedParams,function(params) {
					let glyphs = font.layout(charSequence,undefined,params).glyphs;
					if(glyphs.length == 1) {
						return glyphs[0];
					} else {
						return undefined;
					}
				});
				yagisan_reports_core_font_FontLayoutTypeMapTools.zipToVoid(compositeGlyphs,multiCodePointSubstitution,function(fontkitGlyph,multiCodePointsSubstitution) {
					if(fontkitGlyph != null) {
						if(substitutionFilter(charSequence)) {
							multiCodePointsSubstitution.charSequenceToGlyphAdvances.set(charSequence,yagisan_reports_core_font_glyphdata_GlyphAdvancesString.glyphAdvancesToString([cacheGlyphAdvance(fontkitGlyph)]));
						} else {
							stringsRemovedBySubstitutionFilter.add(charSequence);
						}
					}
				});
			}
		}
	}
	if(includeDefaultSize || options.forceRemovingMostFrequentValue) {
		yagisan_reports_core_font_glyphdata_RawGlyphData_setMostFrequentValueAsDefault(basicGlyphAdvanceRawData);
	}
	let common = yagisan_reports_core_font_glyphdata_ReversibleMap._new();
	let keys = new Set();
	yagisan_reports_core_font_FontLayoutTypeMapTools.iter(singleCodePointSubstitutions,function(rmap) {
		let jsIterator = rmap.entries();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			keys.add(v[0]);
		}
	});
	let jsIterator = keys.values();
	let _g_lastStep = jsIterator.next();
	while(!_g_lastStep.done) {
		let v = _g_lastStep.value;
		_g_lastStep = jsIterator.next();
		let key = v;
		let compare = yagisan_reports_core_font_glyphdata_GlyphDataUtils.equalLoose;
		let this1 = yagisan_reports_core_font_FontLayoutTypeMapTools.getDuplicate(singleCodePointSubstitutions,function(rmap) {
			return rmap.get(key);
		},function(nA,nB) {
			return yagisan_reports_core_font_glyphdata_GlyphDataUtils.equalNullables(nA,nB,compare);
		});
		if(this1 != null) {
			if(this1 != null) {
				yagisan_reports_core_font_FontLayoutTypeMapTools.iter(singleCodePointSubstitutions,function(rmap) {
					rmap.delete(key);
				});
				common.set(key,this1);
			}
		}
	}
	let charSequenceToGlyphAdvancesCommon = yagisan_reports_core_font_glyphdata_ReversibleMap._new();
	let charSequenceToGlyphAdvances = yagisan_reports_core_font_FontLayoutTypeMapTools.map(multiCodePointSubstitution,function(e) {
		return e.charSequenceToGlyphAdvances;
	});
	let keys1 = new Set();
	yagisan_reports_core_font_FontLayoutTypeMapTools.iter(charSequenceToGlyphAdvances,function(rmap) {
		let jsIterator = rmap.entries();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			keys1.add(v[0]);
		}
	});
	let jsIterator1 = keys1.values();
	let _g_lastStep1 = jsIterator1.next();
	while(!_g_lastStep1.done) {
		let v = _g_lastStep1.value;
		_g_lastStep1 = jsIterator1.next();
		let key = v;
		let compare = yagisan_reports_core_font_glyphdata_GlyphDataUtils.equalLoose;
		let this1 = yagisan_reports_core_font_FontLayoutTypeMapTools.getDuplicate(charSequenceToGlyphAdvances,function(rmap) {
			return rmap.get(key);
		},function(nA,nB) {
			return yagisan_reports_core_font_glyphdata_GlyphDataUtils.equalNullables(nA,nB,compare);
		});
		if(this1 != null) {
			if(this1 != null) {
				yagisan_reports_core_font_FontLayoutTypeMapTools.iter(charSequenceToGlyphAdvances,function(rmap) {
					rmap.delete(key);
				});
				charSequenceToGlyphAdvancesCommon.set(key,this1);
			}
		}
	}
	let glyphMapping = { unitsPerEm : font.unitsPerEm, basicGlyphAdvance : basicGlyphAdvanceRawData, singleCodePointSubstitution : singleCodePointSubstitutions, singleCodePointSubstitutionCommon : common, multiCodePointSubstitution : multiCodePointSubstitution, multiCodePointSubstitutionCommon : { charSequenceToGlyphAdvances : charSequenceToGlyphAdvancesCommon}};
	$console.log("font.numGlyphs: " + font.numGlyphs + " 件");
	$console.log("font.characterSet.length: " + font.characterSet.length + " 件");
	$console.log("glyphIdAdvanceMap (temporal): " + glyphIdAdvanceMap.size + " 件");
	$console.group("generated glyphMapping:");
	$console.log("unitsPerEm: " + glyphMapping.unitsPerEm);
	$console.log("basicGlyphAdvance: width " + glyphMapping.basicGlyphAdvance.width.size + " 件, height " + glyphMapping.basicGlyphAdvance.height.size + " 件, common " + glyphMapping.basicGlyphAdvance.common.size + " 件");
	$console.group("substitutions (horizontal):");
	$console.log("singleCodePointSubstitution: " + glyphMapping.singleCodePointSubstitution.horizontal.size + " 件");
	$console.log("multiCodePointSubstitution.charSequenceToGlyphAdvances: " + glyphMapping.multiCodePointSubstitution.horizontal.charSequenceToGlyphAdvances.size + " 件");
	$console.groupEnd();
	$console.group("substitutions (horizontal without ligature):");
	$console.log("singleCodePointSubstitution: " + glyphMapping.singleCodePointSubstitution.horizontalWithoutLigature.size + " 件");
	$console.log("multiCodePointSubstitution.charSequenceToGlyphAdvances: " + glyphMapping.multiCodePointSubstitution.horizontalWithoutLigature.charSequenceToGlyphAdvances.size + " 件");
	$console.groupEnd();
	$console.group("substitutions (vertical):");
	$console.log("singleCodePointSubstitution: " + glyphMapping.singleCodePointSubstitution.vertical.size + " 件");
	$console.log("multiCodePointSubstitution.charSequenceToGlyphAdvances: " + glyphMapping.multiCodePointSubstitution.vertical.charSequenceToGlyphAdvances.size + " 件");
	$console.groupEnd();
	$console.group("substitutions (common):");
	$console.log("singleCodePointSubstitution: " + glyphMapping.singleCodePointSubstitutionCommon.size + " 件");
	$console.log("multiCodePointSubstitution.charSequenceToGlyphAdvances: " + glyphMapping.multiCodePointSubstitutionCommon.charSequenceToGlyphAdvances.size + " 件");
	$console.groupEnd();
	$console.groupEnd();
	if(codePointsRemovedByCodePointFilter.size > 0) {
		$console.group("codePointFilter で除外された文字:");
		let jsIterator = codePointsRemovedByCodePointFilter.values();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			let char = String.fromCodePoint(v);
			let item = "" + char + "\t" + ("U+" + yagisan_reports_core_font_glyphdata_CodePoint.toHex(v));
			$console.log(item);
		}
		$console.groupEnd();
	}
	if(stringsRemovedBySubstitutionFilter.size > 0) {
		$console.group("subtitutionFilter で除外された文字:");
		let jsIterator = stringsRemovedBySubstitutionFilter.values();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			let _this = yagisan_reports_core_font_glyphdata_CodePoint.arrayFrom(v);
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = "U+" + yagisan_reports_core_font_glyphdata_CodePoint.toHex(_this[i]);
			}
			let item = "" + v + "\t" + result.join(" ");
			$console.log(item);
		}
		$console.groupEnd();
	}
	if(codePointsGlyphNotFound.size > 0) {
		$console.group("対応するグリフが無かった文字:");
		let jsIterator = codePointsGlyphNotFound.values();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			let char = String.fromCodePoint(v);
			let item = "" + char + "\t" + ("U+" + yagisan_reports_core_font_glyphdata_CodePoint.toHex(v));
			$console.warn(item);
		}
		$console.groupEnd();
	}
	return glyphMapping;
}
function yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_extractNonBasicStrings(font,$console) {
	let gsub;
	try {
		gsub = yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_extractSubstitutableStringsFromGsub(font,{ onWarning : function(msg) {
			$console.warn(msg);
		}});
	} catch( _g ) {
		let _g1 = haxe_Exception.caught(_g);
		if(_g1.get_message().startsWith("GsubExtractorError: ")) {
			let msg = HxOverrides.substr(_g1.get_message(),"GsubExtractorError: ".length,null);
			$console.error("Failed to extract data from GSUB table. " + msg);
			throw new yagisan_reports_core_font_glyphdata_GlyphDataMappingGeneratorGsubExtractorException(msg,_g1);
		}
		throw haxe_Exception.thrown(_g1);
	}
	let charSequenceList = gsub.charSequenceList.slice();
	let _g = 0;
	let _g1 = font.nonDefaultUVSSet;
	while(_g < _g1.length) {
		let seq = _g1[_g];
		++_g;
		charSequenceList.push(String.fromCodePoint(...[seq.baseCharacter,seq.variationSelector]));
	}
	return { singleCodePoints : gsub.singleCodePoints, charSequenceList : charSequenceList};
}
function yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_anyToTrue(_) {
	return true;
}
class yagisan_reports_core_font_glyphdata_MsgPackExtensionCodec {
	static createForSetMap() {
		let extensionCodec = new js_npm_ExtensionCodec();
		extensionCodec.register({ type : 0, encode : function(object,_context) {
			if(((object) instanceof Set)) {
				let _g = [];
				let jsIterator = object.values();
				let _g_lastStep = jsIterator.next();
				while(!_g_lastStep.done) {
					let v = _g_lastStep.value;
					_g_lastStep = jsIterator.next();
					_g.push(v);
				}
				return js_npm_MsgPack.encode(_g,{ extensionCodec : extensionCodec});
			} else {
				return null;
			}
		}, decode : function(data,extensionType,_context) {
			let array = js_npm_MsgPack.decode(data,{ extensionCodec : extensionCodec});
			return new Set(array);
		}});
		extensionCodec.register({ type : 1, encode : function(object,_context) {
			if(((object) instanceof Map)) {
				let this1 = yagisan_reports_core_font_glyphdata_ReversibleMap.tryCastFrom(object);
				let this2;
				if(this1 != null) {
					let _g = [];
					let jsIterator = yagisan_reports_core_font_glyphdata_ReversibleMap.reverse(this1).entries();
					let _g_lastStep = jsIterator.next();
					while(!_g_lastStep.done) {
						let v = _g_lastStep.value;
						_g_lastStep = jsIterator.next();
						_g.push([v[0],v[1]]);
					}
					this2 = js_npm_MsgPack.encode(_g,{ extensionCodec : extensionCodec});
				} else {
					this2 = undefined;
				}
				return this2;
			} else {
				return null;
			}
		}, decode : function(data,extensionType,_context) {
			let array = js_npm_MsgPack.decode(data,{ extensionCodec : extensionCodec});
			let map = new Map();
			let _g = 0;
			while(_g < array.length) {
				let pair = array[_g];
				++_g;
				map.set(pair[0],pair[1]);
			}
			return yagisan_reports_core_font_glyphdata_ReversibleMap.unreverse(map);
		}});
		extensionCodec.register({ type : 2, encode : function(object,_context) {
			if(((object) instanceof Map)) {
				let _g = [];
				let jsIterator = object.entries();
				let _g_lastStep = jsIterator.next();
				while(!_g_lastStep.done) {
					let v = _g_lastStep.value;
					_g_lastStep = jsIterator.next();
					_g.push([v[0],v[1]]);
				}
				return js_npm_MsgPack.encode(_g,{ extensionCodec : extensionCodec});
			} else {
				return null;
			}
		}, decode : function(data,extensionType,_context) {
			let array = js_npm_MsgPack.decode(data,{ extensionCodec : extensionCodec});
			let map = new Map();
			let _g = 0;
			while(_g < array.length) {
				let pair = array[_g];
				++_g;
				map.set(pair[0],pair[1]);
			}
			return map;
		}});
		return extensionCodec;
	}
}
yagisan_reports_core_font_glyphdata_MsgPackExtensionCodec.__name__ = true;
class yagisan_reports_core_font_glyphdata_GlyphAdvanceRawData {
	static fromRawGlyph(rawGlyph) {
		return yagisan_lib_ds_UInt16Pair.of(rawGlyph.advanceWidth,rawGlyph.advanceHeight);
	}
	static equals(this1,other) {
		return this1 == other;
	}
}
class yagisan_reports_core_font_glyphdata_GlyphAdvancesString {
	static glyphAdvanceToString(a) {
		return "" + yagisan_lib_ds_UInt16Pair.get_x(a) + "_" + yagisan_lib_ds_UInt16Pair.get_y(a);
	}
	static glyphAdvancesToString(a) {
		let _this = a;
		let f = yagisan_reports_core_font_glyphdata_GlyphAdvancesString.glyphAdvanceToString;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = f(_this[i]);
		}
		return result.join(" ");
	}
}
function yagisan_reports_core_font_glyphdata_RawGlyphData_setMostFrequentValueAsDefault(data) {
	if(data.defaultValue != null) {
		throw yagisan_reports_core_font_glyphdata_GlyphDataGeneralException.glyphDataGeneralException("Cannot call setMostFrequentValueAsDefault() twice.");
	}
	let codePointCounterForEachAdvance = new Map();
	let countUp = function(codePointToAdvance) {
		let jsIterator = codePointToAdvance.entries();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			yagisan_reports_core_font_glyphdata_CountMap.incrementFor(codePointCounterForEachAdvance,v[1]);
		}
	};
	countUp(data.width);
	countUp(data.height);
	countUp(data.common);
	let defaultValue = yagisan_reports_core_font_glyphdata_CountMap.getKeyWithHighestCount(codePointCounterForEachAdvance);
	data.defaultValue = defaultValue;
	if(defaultValue != null) {
		let val = defaultValue;
		let map = data.width;
		let _g = [];
		let jsIterator = map.entries();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			if(v[1] == val) {
				_g.push(v[0]);
			}
		}
		let _g1 = 0;
		while(_g1 < _g.length) map.delete(_g[_g1++]);
		let map1 = data.height;
		let _g2 = [];
		let jsIterator1 = map1.entries();
		let _g_lastStep1 = jsIterator1.next();
		while(!_g_lastStep1.done) {
			let v = _g_lastStep1.value;
			_g_lastStep1 = jsIterator1.next();
			if(v[1] == val) {
				_g2.push(v[0]);
			}
		}
		let _g3 = 0;
		while(_g3 < _g2.length) map1.delete(_g2[_g3++]);
		let map2 = data.common;
		let _g4 = [];
		let jsIterator2 = map2.entries();
		let _g_lastStep2 = jsIterator2.next();
		while(!_g_lastStep2.done) {
			let v = _g_lastStep2.value;
			_g_lastStep2 = jsIterator2.next();
			if(v[1] == val) {
				_g4.push(v[0]);
			}
		}
		let _g5 = 0;
		while(_g5 < _g4.length) map2.delete(_g4[_g5++]);
	}
}
class yagisan_reports_core_font_glyphdata_ReversibleMap {
	static markAsReversible(map) {
		map[yagisan_reports_core_font_glyphdata_ReversibleMap.REVERSE_MAP_FLAG_NAME] = true;
		return map;
	}
	static tryCastFrom(map) {
		if(Reflect.field(map,yagisan_reports_core_font_glyphdata_ReversibleMap.REVERSE_MAP_FLAG_NAME) == true) {
			return map;
		} else {
			return undefined;
		}
	}
	static unreverse(reversed) {
		let map = new Map();
		let jsIterator = reversed.entries();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			let value = v[0];
			let jsIterator1 = v[1].values();
			let _g_lastStep1 = jsIterator1.next();
			while(!_g_lastStep1.done) {
				let v = _g_lastStep1.value;
				_g_lastStep1 = jsIterator1.next();
				map.set(v,value);
			}
		}
		return yagisan_reports_core_font_glyphdata_ReversibleMap.markAsReversible(map);
	}
	static _new() {
		let this1 = new Map();
		this1[yagisan_reports_core_font_glyphdata_ReversibleMap.REVERSE_MAP_FLAG_NAME] = true;
		return this1;
	}
	static reverse(this1) {
		let reversed = new Map();
		let jsIterator = this1.entries();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			let key = v[0];
			let value = v[1];
			let x = reversed.get(value);
			let keys;
			if(x != null) {
				keys = x;
			} else {
				let keys1 = new Set();
				reversed.set(value,keys1);
				keys = keys1;
			}
			keys.add(key);
		}
		return reversed;
	}
}
var yagisan_reports_devtool_FsPromises = require("node:fs/promises");
function yagisan_reports_devtool_Main_main() {
	let root = js_npm_yargs_YArgs(js_npm_yargs_YArgsHelpers.hideBin(process.argv)).scriptName("yagisan").strict(true).parserConfiguration(js_npm_yargs_YArgs_$Extern0.from({ greedyArrays : false}));
	root.command("yrt","YRT Manipulation",function(cmd) {
		cmd.command("pack <xml...>","Create a YRT file from an XML file and any assets",function(subcmd) {
			subcmd.positional("xml",{ describe : "XML file (usage: `/path/to/xml` or `/path/to/xml@name`)", type : "string", array : true});
			subcmd.option("asset",{ describe : "Append asset file (usage: `--asset /path/to/aseet@name`)", type : "string", array : true, alias : ["A"]});
			subcmd.option("style",{ describe : "Append style xml file (usage: `--style /path/to/style`)", type : "string", alias : ["S"]});
			subcmd.option("out",{ describe : "Set output file path", type : "string", alias : ["O"], demandOption : true});
			return subcmd.check(function(argv,options) {
				let tmp = argv.asset;
				return yagisan_reports_devtool_command_YrtPackCommand_yrtPackCheck({ xmlPaths : argv.xml, assets : tmp != null ? tmp : [], style : argv.style, outputPath : argv.out});
			});
		},function(argv) {
			let tmp = argv.asset;
			return yagisan_reports_devtool_command_YrtPackCommand_yrtPack({ xmlPaths : argv.xml, assets : tmp != null ? tmp : [], style : argv.style, outputPath : argv.out});
		});
		return cmd.command("pack-alpha <xml>","Create a YRT file from an XML file and any assets (legacy format for <= v1.0.0-alpha.13)",function(subcmd) {
			subcmd.positional("xml",{ describe : "XML file path", type : "string"});
			subcmd.option("asset",{ describe : "Append asset (usage: `--asset /path/to/aseet@id`)", type : "string", array : true, alias : ["A"]});
			subcmd.option("out",{ describe : "Set output file path", type : "string", alias : ["O"]});
			return subcmd.check(function(argv,options) {
				let tmp = argv.asset;
				return yagisan_reports_devtool_command_YrtPackCommand_yrtAlphaPackCheck({ xmlPath : argv.xml, assets : tmp != null ? tmp : [], outputPath : argv.out});
			});
		},function(argv) {
			let tmp = argv.asset;
			return yagisan_reports_devtool_command_YrtPackCommand_yrtAlphaPack({ xmlPath : argv.xml, assets : tmp != null ? tmp : [], outputPath : argv.out});
		});
	},function(_) {
		root.showHelp();
	});
	root.command("glyphdata","Glyphdata Manipulation",function(cmd) {
		return cmd.command("generate <font>","Generate glyphdata from a font file",function(subcmd) {
			subcmd.positional("font",{ describe : "Font file path", type : "string"});
			subcmd.option("out",{ describe : "Set output file path", type : "string", alias : ["O"]});
			return subcmd.check(function(argv,options) {
				return yagisan_reports_devtool_command_GlyphdataCommand_glyphdataGenerateCheck({ fontPath : argv.font, outputPath : argv.out});
			});
		},function(argv) {
			return yagisan_reports_devtool_command_GlyphdataCommand_glyphdataGenerate({ fontPath : argv.font, outputPath : argv.out});
		});
	},function(_) {
		root.showHelp();
	});
	let $arguments = root.parse();
	let tmp = $arguments != null ? $arguments._ : null;
	let tmp1 = tmp != null ? tmp.length : null;
	if((tmp1 != null ? tmp1 : Infinity) <= 0) {
		root.showHelp();
	}
}
class yagisan_reports_shared_GlyphdataFormat {
	static generate(fontBuffer) {
		if(!((fontBuffer) instanceof Uint8Array)) {
			return yagisan_reports_shared_GenerateGlyphdataResult.InvalidFontBufferDataTypeError;
		}
		let rawGlyphData;
		let _g = yagisan_reports_core_font_glyphdata_GlyphDataGenerator_generateRawGlyphData(fontBuffer,new yagisan_reports_core_font_glyphdata_GlyphMappingGeneratorOptions(null,null,null,null,null));
		switch(_g._hx_index) {
		case 0:
			rawGlyphData = _g.glyphData;
			break;
		case 1:
			return yagisan_reports_shared_GenerateGlyphdataResult.UnsupportedFontFileError(_g.type);
		case 2:
			return yagisan_reports_shared_GenerateGlyphdataResult.GlyphDataGeneratorFatalError(_g.error.message);
		}
		return yagisan_reports_shared_GenerateGlyphdataResult.Success(js_npm_MsgPack.encode(rawGlyphData,{ extensionCodec : yagisan_reports_shared_GlyphdataFormat.codec}));
	}
}
yagisan_reports_shared_GlyphdataFormat.__name__ = true;
var yagisan_reports_shared_GenerateGlyphdataResult = $hxEnums["yagisan.reports.shared.GenerateGlyphdataResult"] = { __ename__:true,__constructs__:null
	,Success: ($_=function(glyphdata) { return {_hx_index:0,glyphdata:glyphdata,__enum__:"yagisan.reports.shared.GenerateGlyphdataResult",toString:$estr}; },$_._hx_name="Success",$_.__params__ = ["glyphdata"],$_)
	,InvalidFontBufferDataTypeError: {_hx_name:"InvalidFontBufferDataTypeError",_hx_index:1,__enum__:"yagisan.reports.shared.GenerateGlyphdataResult",toString:$estr}
	,UnsupportedFontFileError: ($_=function(type) { return {_hx_index:2,type:type,__enum__:"yagisan.reports.shared.GenerateGlyphdataResult",toString:$estr}; },$_._hx_name="UnsupportedFontFileError",$_.__params__ = ["type"],$_)
	,GlyphDataGeneratorFatalError: ($_=function(error) { return {_hx_index:3,error:error,__enum__:"yagisan.reports.shared.GenerateGlyphdataResult",toString:$estr}; },$_._hx_name="GlyphDataGeneratorFatalError",$_.__params__ = ["error"],$_)
};
yagisan_reports_shared_GenerateGlyphdataResult.__constructs__ = [yagisan_reports_shared_GenerateGlyphdataResult.Success,yagisan_reports_shared_GenerateGlyphdataResult.InvalidFontBufferDataTypeError,yagisan_reports_shared_GenerateGlyphdataResult.UnsupportedFontFileError,yagisan_reports_shared_GenerateGlyphdataResult.GlyphDataGeneratorFatalError];
function yagisan_reports_devtool_command_GlyphdataCommand_glyphdataGenerateCheck(params) {
	if(!js_node_Fs.existsSync(params.fontPath)) {
		throw haxe_Exception.thrown("Could not find font file: " + params.fontPath);
	}
	return true;
}
$hx_exports["yagisan"]["reports"]["devtool"]["command"]["GlyphdataCommand"]["glyphdataGenerateCheck"] = yagisan_reports_devtool_command_GlyphdataCommand_glyphdataGenerateCheck;
class yagisan_reports_shared_LegacyYrtFormat {
	static packYrt(layoutXml,assets) {
		let assetObject = { };
		let hasAsset = false;
		if(assets != null && assets.size > 0) {
			let jsIterator = assets.entries();
			let _g_lastStep = jsIterator.next();
			while(!_g_lastStep.done) {
				let v = _g_lastStep.value;
				_g_lastStep = jsIterator.next();
				let v1 = v[1];
				if(v1 != null && ((v1) instanceof Uint8Array)) {
					assetObject[v[0]] = v1;
					hasAsset = true;
				}
			}
		}
		if(hasAsset) {
			return js_npm_MsgPack.encode([layoutXml,assetObject]);
		} else {
			return js_npm_MsgPack.encode([layoutXml]);
		}
	}
}
yagisan_reports_shared_LegacyYrtFormat.__name__ = true;
class yagisan_reports_shared_YrtFormat {
	static pack(yrt) {
		if(yrt.layouts.length <= 0) {
			throw haxe_Exception.thrown("YRTパッケージはレイアウトXMLを1つ以上含む必要があります。");
		}
		let _this = yrt.layouts;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			let x = _this[i];
			result[i] = [x.name,x.xml];
		}
		let yrt1 = yrt.style;
		let this1 = yrt.assets;
		let tmp;
		if(this1 != null) {
			if(this1.size > 0) {
				let obj = { };
				let jsIterator = this1.entries();
				let _g_lastStep = jsIterator.next();
				while(!_g_lastStep.done) {
					let v = _g_lastStep.value;
					_g_lastStep = jsIterator.next();
					obj[v[0]] = v[1];
				}
				tmp = obj;
			} else {
				tmp = null;
			}
		} else {
			tmp = null;
		}
		return js_npm_MsgPack.encode(["YRT",1,{ l : result, s : yrt1, a : tmp}]);
	}
}
yagisan_reports_shared_YrtFormat.__name__ = true;
function yagisan_reports_devtool_command_YrtPackCommand_yrtAlphaPackCheck(params) {
	if(!js_node_Fs.existsSync(params.xmlPath)) {
		throw haxe_Exception.thrown("Could not find xml: " + params.xmlPath);
	}
	let idSet = new Set();
	let _g = 0;
	let _g1 = params.assets;
	while(_g < _g1.length) {
		let asset = _g1[_g];
		++_g;
		let def = yagisan_reports_devtool_command_YrtPackCommand_parseAssetString(asset);
		let path = def.path;
		let id = def.id;
		if(path == "" || id == "") {
			throw haxe_Exception.thrown("Invalid argument: asset " + asset);
		}
		if(!js_node_Fs.existsSync(path)) {
			throw haxe_Exception.thrown("Could not find asset: " + path);
		}
		if(idSet.has(id)) {
			throw haxe_Exception.thrown("Same asset id specified: " + id);
		}
		idSet.add(id);
	}
	return true;
}
$hx_exports["yagisan"]["reports"]["devtool"]["command"]["YrtPackCommand"]["yrtAlphaPackCheck"] = yagisan_reports_devtool_command_YrtPackCommand_yrtAlphaPackCheck;
function yagisan_reports_devtool_command_YrtPackCommand_parseAssetString(value) {
	let tokens = value.split("@");
	let tmp = tokens[1];
	let tmp1 = tmp != null ? StringTools.trim(tmp) : null;
	return { path : StringTools.trim(tokens[0]), id : tmp1 != null ? tmp1 : ""};
}
function yagisan_reports_devtool_command_YrtPackCommand_loadXml(xmlPath) {
	return yagisan_reports_devtool_FsPromises.readFile(xmlPath,{ encoding : "utf-8"});
}
function yagisan_reports_devtool_command_YrtPackCommand_loadAssets(assets) {
	let _this = assets;
	let result = new Array(_this.length);
	let _g = 0;
	let _g1 = _this.length;
	while(_g < _g1) {
		let i = _g++;
		let def = yagisan_reports_devtool_command_YrtPackCommand_parseAssetString(_this[i]);
		let id = def.id;
		result[i] = yagisan_reports_devtool_FsPromises.readFile(def.path).then(function(buff) {
			return new extype_Tuple2(id,buff);
		});
	}
	return Promise.all(result).then(function(loadedAssets) {
		let assets = new Map();
		let _g = 0;
		let _g1 = loadedAssets;
		while(_g < _g1.length) {
			let x = _g1[_g];
			++_g;
			assets.set(x.value1,x.value2);
		}
		return assets;
	});
}
function yagisan_reports_devtool_command_YrtPackCommand_yrtPackCheck(params) {
	if(params.xmlPaths.length <= 0) {
		throw haxe_Exception.thrown("At least one XML file must be specified");
	}
	let _g = 0;
	let _g1 = params.xmlPaths;
	while(_g < _g1.length) {
		let xmlPath = StringTools.trim(_g1[_g++].split("@")[0]);
		if(!js_node_Fs.existsSync(xmlPath)) {
			throw haxe_Exception.thrown("Could not find xml: " + xmlPath);
		}
	}
	if(params.style != null && !js_node_Fs.existsSync(params.style)) {
		throw haxe_Exception.thrown("Could not find style xml: " + params.style);
	}
	let idSet = new Set();
	let _g2 = 0;
	let _g3 = params.assets;
	while(_g2 < _g3.length) {
		let asset = _g3[_g2];
		++_g2;
		let def = yagisan_reports_devtool_command_YrtPackCommand_parseAssetString(asset);
		let path = def.path;
		let id = def.id;
		if(path == "" || id == "") {
			throw haxe_Exception.thrown("Invalid argument: asset " + asset);
		}
		if(!js_node_Fs.existsSync(path)) {
			throw haxe_Exception.thrown("Could not find asset: " + path);
		}
		if(idSet.has(id)) {
			throw haxe_Exception.thrown("Same asset id specified: " + id);
		}
		idSet.add(id);
	}
	return true;
}
function yagisan_reports_devtool_command_YrtPackCommand_getOutputPath(params) {
	let path = js_node_Path.parse(StringTools.trim(params.xmlPaths[0].split("@")[0]));
	let this1 = params.outputPath;
	let x = js_node_Path.join(path.dir,"" + path.name + ".yrt");
	if(this1 != null) {
		return this1;
	} else {
		return x;
	}
}
function yagisan_reports_devtool_command_YrtPackCommand_loadXmls(xmlPaths) {
	let _this = xmlPaths;
	let result = new Array(_this.length);
	let _g = 0;
	let _g1 = _this.length;
	while(_g < _g1) {
		let i = _g++;
		let tokens = _this[i].split("@");
		let xmlPath = StringTools.trim(tokens[0]);
		let tmp = tokens[1];
		let customName = tmp != null ? StringTools.trim(tmp) : null;
		let name = customName != null && customName != "" ? customName : undefined;
		result[i] = yagisan_reports_devtool_FsPromises.readFile(xmlPath,{ encoding : "utf-8"}).then(function(xml) {
			return { name : name, xml : xml};
		});
	}
	return Promise.all(result);
}
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
{
	String.__name__ = true;
	Array.__name__ = true;
}
js_Boot.__toStr = ({ }).toString;
yagisan_reports_core_font_glyphdata_CodePoint.emptyArray = [];
var yagisan_reports_core_font_glyphdata_GlyphDataVersion_currentGlyphDataVersion = yagisan_reports_core_font_glyphdata_GlyphDataVersion.from("1.0");
var yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_shapers = { horizontal : new yagisan_reports_core_font_glyphdata_shapers_HorizontalPresetShaper(), horizontalWithoutLigature : new yagisan_reports_core_font_glyphdata_shapers_BasicPresetShaper(), vertical : new yagisan_reports_core_font_glyphdata_shapers_VerticalPresetShaper()};
var yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_layoutAdvancedParams = yagisan_reports_core_font_FontLayoutTypeMapTools.map(yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_shapers,function(shaper) {
	return { script : "DFLT", language : null, direction : null, shaper : shaper, skipPerGlyphPositioning : true};
});
var yagisan_reports_core_font_glyphdata_GlyphMappingGenerator_extractSubstitutableStringsFromGsub = (() => {

// ---- exception --------------------------------------------------------------

class GsubExtractorError extends Error {
  /**
   * @param {string} message
   * @param {TTFFont} [font]
   */
  constructor(message, font) {
    let msg = `GsubExtractorError: ${message}`;
    if (font) msg += ` (${font.fullName})`;
    super(msg);
    this.font = font;
  }
}

// ---- utils ------------------------------------------------------------------

/**
 * ある決まった長さの文字列について、各indexごとに複数の文字候補があるとき、
 * 全体の文字列としてありえる組み合わせをすべて列挙します。
 *
 * @param {string[][]} charCandidatesForEachStringIndex
 *   たとえば2文字の文字列で、1文字目がAまたはB、2文字目がCまたはDだとしたら、
 *   `[["A", "B"], ["C", "D"]]` のように入力します。
 * @returns {string[]} 入力 `[["A", "B"], ["C", "D"]]` に対して
 *   `["AC", "BC", "AD", "BD"]` のような出力を返します（順不同）。
 */
function generateCharCombinations(charCandidatesForEachStringIndex) {
  if (charCandidatesForEachStringIndex.length === 0) return [];

  const combinations = [];

  /**
   * @param {string[]} currentCombination
   * @param {string[][]} remainingArrays
   */
  function buildCombinationRecursive(currentCombination, remainingArrays) {
    if (remainingArrays.length === 0) {
      combinations.push(currentCombination.join(""));
      return;
    }

    const [firstArray, ...restArrays] = remainingArrays;
    for (const char of firstArray) {
      currentCombination.push(char);
      buildCombinationRecursive(currentCombination, restArrays);
      currentCombination.pop();
    }
  }

  buildCombinationRecursive([], charCandidatesForEachStringIndex);

  return combinations;
}

// ---- extractor --------------------------------------------------------------

class GsubExtractor {
  /**
   * `scriptTagFilter` を通過する script が実際のGSUBテーブル内に
   * 一つも見つからない場合のフォールバック候補。
   *
   * fontkit の `OTProcessor` モジュールと同じ設定にする
   */
  static DEFAULT_SCRIPTS = ["DFLT", "dflt", "latn"];

  /**
   * @type {GsubExtractorOptions | undefined}
   */
  static defaultOptions = undefined;

  /**
   * `GsubExtractor` インスタンスを作成します。
   * GSUBテーブルが存在しない場合は `null` を返します。
   *
   * @param {TTFFont} font
   * @param {Partial<GsubExtractorOptions>} [options]
   * @returns {GsubExtractor | null}
   */
  static create(font, options) {
    /** @type {any} */
    const gsub = font.GSUB;

    return gsub ? new GsubExtractor(font, gsub, options) : null;
  }

  /**
   * @returns {GsubExtractorOptions}
   */
  static createDefaultOptions() {
    const featureTags = new Set([
      "ccmp", // common
      "locl", // common
      "rclt", // common
      "rlig", // common
      "calt", // horizontal
      "clig", // horizontal
      "liga", // horizontal
      "vert", // vertical
    ]);

    const scriptTags = new Set([
      "DFLT",
      // "latn",
      // "hani",
      // "kana",
    ]);

    /** @type {Set<undefined | string>} **/
    const langSysTags = new Set([
      undefined, // defaultLangSys に相当
      // "JAN",
    ]);

    return {
      featureTagFilter: (tag) => featureTags.has(tag),
      scriptTagFilter: (tag) => scriptTags.has(tag),
      langSysTagFilter: (tag) => langSysTags.has(tag),
      onWarning: (_) => {},
    };
  }

  /**
   * fontkit と同じ方法で、このフォントのデフォルトの script を特定します。
   *
   * @param {ScriptList} scriptList
   * @returns {string | null} default script tag
   *
   * @see findScript in fontkit `OTProcessor`
   */
  static findDefaultScript(scriptList) {
    for (let candidate of GsubExtractor.DEFAULT_SCRIPTS) {
      for (let record of scriptList) {
        if (record.tag === candidate) {
          return record.tag;
        }
      }
    }

    return null;
  }

  /** @type {GsubTable} */
  gsub;

  /** @type {GsubExtractorOptions["featureTagFilter"]} */
  featureTagFilter;
  /** @type {GsubExtractorOptions["langSysTagFilter"]} */
  langSysTagFilter;
  /** @type {GsubExtractorOptions["scriptTagFilter"]} */
  scriptTagFilter;
  /** @type {GsubExtractorOptions["onWarning"]} */
  onWarning;

  /** @type {string | null} */
  defaultScriptTag;

  /**
   * インスタンスの作成には `create()` を使ってください。
   *
   * @param {TTFFont} font
   * @param {GsubTable} gsub
   * @param {Partial<GsubExtractorOptions>} [options]
   */
  constructor(font, gsub, options) {
    this.font = font;
    this.gsub = gsub;

    const defOpt =
      GsubExtractor.defaultOptions ??
      (GsubExtractor.defaultOptions = GsubExtractor.createDefaultOptions());

    this.featureTagFilter =
      options?.featureTagFilter ?? defOpt.featureTagFilter;
    this.langSysTagFilter =
      options?.langSysTagFilter ?? defOpt.langSysTagFilter;
    this.scriptTagFilter = options?.scriptTagFilter ?? defOpt.scriptTagFilter;
    this.onWarning = options?.onWarning ?? defOpt.onWarning;

    this.defaultScriptTag = GsubExtractor.findDefaultScript(
      this.gsub.scriptList
    );
  }

  /**
   * @param {GsubSingleSubstSubtable[]} lookupSubTables
   * @returns {ExtractedGsubSingleSubstSubtable[]}
   */
  extractLookupType1SubTables(lookupSubTables) {
    return lookupSubTables.map((subTable) => {
      switch (subTable.version) {
        case 1:
          return this.getGlyphIDsFromCoverage(subTable.coverage).map(
            (srcId) => {
              const destId = srcId + subTable.deltaGlyphID;
              return { srcId, destId };
            }
          );

        case 2:
          const destGlyphIDs = [];
          for (let i = 0; i < subTable.glyphCount; ++i) {
            destGlyphIDs.push(subTable.substitute.get(i));
          }
          return this.getGlyphIDsFromCoverage(subTable.coverage).map(
            (srcId) => {
              const coverageIndex = this.getCoverageIndex(
                subTable.coverage,
                srcId
              );
              const destId = destGlyphIDs[coverageIndex];
              return { srcId, destId };
            }
          );

        default:
          throw new GsubExtractorError(
            // @ts-ignore
            `Unknown subTable version: ${subTable.version}`,
            this.font
          );
      }
    });
  }

  /**
   * @param {GsubLigatureSubstSubtable[]} lookupSubTables
   * @returns {ExtractedGsubLigatureSubstSubtable[]}
   */
  extractLookupType4SubTables(lookupSubTables) {
    return lookupSubTables.map((subTable) => {
      return this.getGlyphIDsFromCoverage(subTable.coverage).map((srcId) => {
        const coverageIndex = this.getCoverageIndex(subTable.coverage, srcId);
        const ligatureSet = subTable.ligatureSets.get(coverageIndex);
        const ligatures = ligatureSet.map((ligature) => {
          const srcIds = [srcId].concat(ligature.components);
          const destId = ligature.glyph;
          return { srcIds, destId };
        });
        return { srcId, ligatures };
      });
    });
  }

  /**
   * @param {GsubLookupTable} lookup
   * @returns {ExtractedLookup}
   */
  extractLookup(lookup) {
    const _flags = lookup.flags;
    /** @type {LookupFlags} **/
    const flags = {
      markAttachmentType: _flags.markAttachmentType,
      flags: {
        rightToLeft: _flags.flags.rightToLeft,
        ignoreBaseGlyphs: _flags.flags.ignoreBaseGlyphs,
        ignoreLigatures: _flags.flags.ignoreLigatures,
        ignoreMarks: _flags.flags.ignoreMarks,
        useMarkFilteringSet: _flags.flags.useMarkFilteringSet,
      },
    };
    if (flags.markAttachmentType !== 0) {
      this.onWarning(
        `Found lookup with markAttachmentType: ${flags.markAttachmentType}`
      );
    }
    for (const key of Object.keys(flags.flags)) {
      if (flags.flags[key] === true) {
        this.onWarning(`Found lookup with flags.${key}: true`);
      }
    }

    switch (lookup.lookupType) {
      case 1:
        return {
          flags,
          lookupType: lookup.lookupType,
          subTables: this.extractLookupType1SubTables(lookup.subTables),
        };
      case 4:
        return {
          flags,
          lookupType: lookup.lookupType,
          subTables: this.extractLookupType4SubTables(lookup.subTables),
        };
      default:
        this.onWarning(
          `Ignoring unsupported GSUB lookupType: ${lookup.lookupType}`
        );
        return {
          flags,
          lookupType: lookup.lookupType,
          subTables: [], // 未対応のため、実際のデータを無視して空配列を返します。
        };
    }
  }

  /**
   * @param {FeatureTable} feature
   * @returns {ExtractedFeature}
   */
  extractFeature(feature) {
    const { featureParams, lookupListIndexes } = feature;

    if (featureParams != null) {
      /*
        参考: https://learn.microsoft.com/en-us/typography/opentype/spec/chapter2
        
        > Currently, feature parameters tables are defined only for the following features:
        >   'cv01' – 'cv99'
        >   'size'
        >   'ss01' – 'ss20'
      */
      this.onWarning(`Found feature with featureParams: ${featureParams}`);
    }

    const { lookupList } = this.gsub;

    /** @type {ExtractedFeature["lookups"]} **/
    const lookups = lookupListIndexes.map((lookupListIndex) => {
      const lookup = this.extractLookup(lookupList.get(lookupListIndex));
      return { lookupListIndex, ...lookup };
    });

    return {
      featureParams,
      lookups,
    };
  }

  /**
   * @param {LangSysTable} langSys
   * @returns {ExtractedLangSys}
   */
  extractLangSys(langSys) {
    const { reqFeatureIndex, featureIndexes } = langSys;

    const { featureList } = this.gsub;

    /** @type {ExtractedLangSys["features"]} **/
    const features = [];
    if (
      reqFeatureIndex !== 0xffff &&
      featureIndexes.indexOf(reqFeatureIndex) < 0
    ) {
      const featureRecord = featureList[reqFeatureIndex];
      features.push({
        tag: featureRecord.tag,
        isRequired: true,
        ...this.extractFeature(featureRecord.feature),
      });
    }
    for (const i of featureIndexes) {
      const featureRecord = featureList[i];
      if (i !== reqFeatureIndex && !this.featureTagFilter(featureRecord.tag))
        continue;
      features.push({
        tag: featureRecord.tag,
        isRequired: i === reqFeatureIndex,
        ...this.extractFeature(featureRecord.feature),
      });
    }

    return { features };
  }

  /**
   * @param {ScriptTable} script
   * @returns {ExtractedScript}
   */
  extractScript(script) {
    /** @type {ExtractedScript["languageSystems"]} **/
    const languageSystems = [];

    if (this.langSysTagFilter(undefined) && script.defaultLangSys) {
      languageSystems.push({
        tag: undefined,
        ...this.extractLangSys(script.defaultLangSys),
      });
    }

    if (script.langSysRecords.length > 0) {
      for (const langSysRecord of script.langSysRecords) {
        if (!this.langSysTagFilter(langSysRecord.tag)) continue;
        languageSystems.push({
          tag: langSysRecord.tag,
          ...this.extractLangSys(langSysRecord.langSys),
        });
      }
    }

    return { languageSystems };
  }

  /**
   * @returns {ExtractedGsub}
   */
  extractGsubTable() {
    /** @type {ScriptRecord[]} **/
    const scriptRecords = [];

    for (const scriptRecord of this.gsub.scriptList) {
      if (this.scriptTagFilter(scriptRecord.tag)) {
        scriptRecords.push(scriptRecord);
      }
    }

    if (scriptRecords.length === 0) {
      // デフォルトの script へのフォールバック
      for (const scriptRecord of this.gsub.scriptList) {
        if (scriptRecord.tag === this.defaultScriptTag) {
          scriptRecords.push(scriptRecord);
        }
      }
    }

    /** @type {ExtractedGsub["scripts"]} **/
    const scripts = scriptRecords.map((scriptRecord) => {
      return {
        tag: scriptRecord.tag,
        ...this.extractScript(scriptRecord.script),
      };
    });

    return { scripts };
  }

  /**
   * @param {CoverageTable} coverage
   * @param {number} glyphId
   * @returns {number}
   */
  getCoverageIndex(coverage, glyphId) {
    switch (coverage.version) {
      case 1:
        return coverage.glyphs.indexOf(glyphId);

      case 2:
        for (const range of coverage.rangeRecords) {
          if (range.start <= glyphId && glyphId <= range.end) {
            return range.startCoverageIndex + glyphId - range.start;
          }
        }
        break;

      default:
        throw new GsubExtractorError(
          // @ts-ignore
          `Unknown coverage version: ${coverage.version}`,
          this.font
        );
    }

    return -1;
  }

  /**
   * @param {CoverageTable} coverage
   * @returns {number[]}
   */
  getGlyphIDsFromCoverage(coverage) {
    switch (coverage.version) {
      case 1:
        return coverage.glyphs;

      case 2:
        const glyphs = [];
        for (const range of coverage.rangeRecords) {
          for (let id = range.start; id <= range.end; ++id) {
            glyphs.push(id);
          }
        }
        return glyphs;

      default:
        throw new GsubExtractorError(
          // @ts-ignore
          `Unknown coverage version: ${coverage.version}`,
          this.font
        );
    }
  }
}

// ---- after extraction -------------------------------------------------------

/**
 * GSUBテーブルからの抽出内容に含まれるすべての Lookup を実行順序に従ってフラットに並べます。
 *
 * @param {ExtractedGsub} gsub
 * @returns {FlattenedLookup[]}
 */
function flattenAndOrderLookups(gsub) {
  return gsub.scripts
    .flatMap((script) =>
      script.languageSystems.map((langSys) => ({
        tags: { script: script.tag },
        langSys: langSys,
      }))
    )
    .flatMap((record) =>
      record.langSys.features.map((feature) => ({
        tags: { ...record.tags, langSys: record.langSys.tag },
        feature: feature,
      }))
    )
    .flatMap((record) =>
      record.feature.lookups.map((lookup) => ({
        tags: { ...record.tags, feature: record.feature.tag },
        lookup: lookup,
      }))
    )
    .sort((a, b) => a.lookup.lookupListIndex - b.lookup.lookupListIndex)
    .map((record) => {
      const { tags, lookup } = record;
      const { lookupListIndex, lookupType } = lookup;
      /** @type {ExtractedGsubLigatureSubstSubtable[]} **/
      let subTables;
      switch (lookupType) {
        case 1:
          subTables = lookup.subTables.map((subTable) => {
            return subTable.map((e) => ({
              srcId: e.srcId,
              ligatures: [{ srcIds: [e.srcId], destId: e.destId }],
            }));
          });
          break;
        case 4:
          subTables = lookup.subTables;
          break;
        default:
          // 1, 4 以外は未対応のため、ここは常に空配列になります。
          subTables = lookup.subTables;
          break;
      }

      return { tags, lookupListIndex, lookupType, subTables };
    });
}

/**
 * @param {ExtractedGsub} gsub
 * @returns { tags: Tags; lookupListIndex: number; lookupType: number; mapping: JoinedSubstitutionMapping; }[]}
 */
function resolveGsubLookupChains(gsub) {
  const lookups = flattenAndOrderLookups(gsub);

  const joinedMappingList = [];

  for (const lookup of lookups) {
    const { tags, lookupListIndex, lookupType, subTables } = lookup;

    for (
      let currSubTableIndex = 0;
      currSubTableIndex < subTables.length;
      ++currSubTableIndex
    ) {
      const subTableEntries = subTables[currSubTableIndex];

      /** @type {JoinedSubstitutionMapping} **/
      const joinedMapping = subTableEntries.map((entry) => {
        const joinedLigatures = entry.ligatures.flatMap((ligature) => {
          /** @type {JoinedLigature[]} **/
          const joinedLigaturesSubArray = [
            {
              destId: ligature.destId,
              srcIds: ligature.srcIds,
              joinedSubTableIndex: "none",
            },
          ];
          for (
            let srcIdIndex = 0;
            srcIdIndex < ligature.srcIds.length;
            ++srcIdIndex
          ) {
            const srcId = ligature.srcIds[srcIdIndex];

            for (
              let precSubTableIndex = 0;
              precSubTableIndex < currSubTableIndex;
              ++precSubTableIndex
            ) {
              const precSubTable = subTables[precSubTableIndex];
              for (const precEntry of precSubTable) {
                for (const precLigature of precEntry.ligatures) {
                  if (precLigature.destId === srcId) {
                    // 先行する置換ルールの出力 (destId) が、現在処理中の置換ルールの入力文字列の一部 (srcIds[i]) と同じなら、
                    // 置換が連鎖する可能性があることを意味するので、合成した置換ルールをリストに加えます。
                    const newSrcIds = [...ligature.srcIds];
                    newSrcIds.splice(srcIdIndex, 1, ...precLigature.srcIds);
                    joinedLigaturesSubArray.push({
                      destId: ligature.destId,
                      srcIds: newSrcIds,
                      joinedSubTableIndex: precSubTableIndex,
                    });
                  }
                }
              }
            }
          }

          return joinedLigaturesSubArray;
        });

        /** @type {JoinedSubstitutionMappingEntry} **/
        const joinedRule = {
          srcId: entry.srcId,
          ligatures: joinedLigatures,
        };

        return joinedRule;
      });

      joinedMappingList.push({
        tags,
        lookupListIndex,
        lookupType,
        mapping: joinedMapping,
      });
    }
  }

  return joinedMappingList;
}

// ---- one-stop ---------------------------------------------------------------

/**
 * フォントのGSUBテーブルを元に、`options` で与えられた条件下でグリフ置換の発生する可能性のある
 * 文字の並びかたのパターンをすべて洗い出します。
 *
 * 実際のグリフ置換では OpenType Features の有効化状況などによって結果が変わってくるので、
 * 本当にグリフ置換が発生するかどうかは、各パターンを個別の条件で再確認して絞り込んでください。
 *
 * @param {TTFFont} font
 * @param {Partial<GsubExtractorOptions>} [options]
 * @returns {SubstitutableStrings}
 */
function extractSubstitutableStrings(font, options) {
  const gsubExtractor = GsubExtractor.create(font, options);
  if (!gsubExtractor) {
    return {
      singleCodePoints: new Set(),
      charSequenceList: [],
    };
  }

  const gsub = gsubExtractor.extractGsubTable();
  const resolvedItems = resolveGsubLookupChains(gsub);

  /** @type {Set<number>} **/
  const singleCodePoints = new Set();

  /** @type {Set<string>} **/
  const charSequences = new Set();

  for (const { mapping } of resolvedItems) {
    for (const rule of mapping) {
      for (const subst of rule.ligatures) {
        const charsForEachSrcId = subst.srcIds.map((id) =>
          font.stringsForGlyph(id)
        );
        const srcStrCandidates = generateCharCombinations(charsForEachSrcId);
        for (const srcStr of srcStrCandidates) {
          const codePointCount = [...srcStr].length;
          let firstCodePoint = srcStr.codePointAt(0);
          switch (codePointCount) {
            case 0:
              break;
            case 1:
              if (!firstCodePoint)
                throw new GsubExtractorError("Unexpected nullish", font);
              singleCodePoints.add(firstCodePoint);
              break;
            default:
              charSequences.add(srcStr);
              break;
          }
        }
      }
    }
  }

  const charSequenceList = [...charSequences];

  return { singleCodePoints, charSequenceList };
}



return extractSubstitutableStrings;
})();
yagisan_reports_core_font_glyphdata_ReversibleMap.REVERSE_MAP_FLAG_NAME = "__REVERSEMAP__";
yagisan_reports_shared_GlyphdataFormat.codec = yagisan_reports_core_font_glyphdata_MsgPackExtensionCodec.createForSetMap();
var yagisan_reports_devtool_command_GlyphdataCommand_glyphdataGenerate = $hx_exports["yagisan"]["reports"]["devtool"]["command"]["GlyphdataCommand"]["glyphdataGenerate"] = (async function(params) {
	let fontBuffer = (await yagisan_reports_devtool_FsPromises.readFile(params.fontPath));
	let result = yagisan_reports_shared_GlyphdataFormat.generate(fontBuffer);
	let glyphdataBuffer;
	switch(result._hx_index) {
	case 0:
		glyphdataBuffer = result.glyphdata;
		break;
	case 1:
		throw haxe_Exception.thrown("Invalid font buffer data type. Expected Uint8Array.");
	case 2:
		throw haxe_Exception.thrown("Unsupported font file type: " + result.type);
	case 3:
		throw haxe_Exception.thrown("Fatal error during glyph data generation: " + result.error);
	}
	let path = js_node_Path.parse(params.fontPath);
	let this1 = params.outputPath;
	let x = js_node_Path.join(path.dir,"" + path.name + ".glyphdata");
	(await yagisan_reports_devtool_FsPromises.writeFile(this1 != null ? this1 : x,js_node_buffer_Buffer.from(glyphdataBuffer),{ flag : "w"}));
});
var yagisan_reports_devtool_command_YrtPackCommand_yrtAlphaPack = $hx_exports["yagisan"]["reports"]["devtool"]["command"]["YrtPackCommand"]["yrtAlphaPack"] = (async function(params) {
	let xml = (await yagisan_reports_devtool_command_YrtPackCommand_loadXml(params.xmlPath));
	let assets = (await yagisan_reports_devtool_command_YrtPackCommand_loadAssets(params.assets));
	let template = yagisan_reports_shared_LegacyYrtFormat.packYrt(xml,assets);
	let path = js_node_Path.parse(params.xmlPath);
	let this1 = params.outputPath;
	let x = js_node_Path.join(path.dir,"" + path.name + ".yrt");
	(await yagisan_reports_devtool_FsPromises.writeFile(this1 != null ? this1 : x,js_node_buffer_Buffer.from(template),{ flag : "w"}));
});
var yagisan_reports_devtool_command_YrtPackCommand_yrtPack = (async function(params) {
	let layouts = (await yagisan_reports_devtool_command_YrtPackCommand_loadXmls(params.xmlPaths));
	let assets = params.assets.length > 0 ? (await yagisan_reports_devtool_command_YrtPackCommand_loadAssets(params.assets)) : null;
	let style;
	if(params.style != null) {
		let styleXml = (await yagisan_reports_devtool_command_YrtPackCommand_loadXml(params.style));
		style = styleXml;
	} else {
		style = undefined;
	}
	let packed = yagisan_reports_shared_YrtFormat.pack({ layouts : layouts, style : style, assets : assets});
	(await yagisan_reports_devtool_FsPromises.writeFile(yagisan_reports_devtool_command_YrtPackCommand_getOutputPath(params),js_node_buffer_Buffer.from(packed),{ flag : "w"}));
});
yagisan_reports_devtool_Main_main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, {});
